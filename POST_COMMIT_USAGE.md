# Post-Commit Visual Regression Usage Examples

This document provides practical examples of using the `post_commit_visual_regression.yml` workflow.

## Example 1: Automatic Execution on Push

When you commit visual outputs to your repository, the workflow runs automatically:

```bash
# In your development workflow:
# 1. Generate visual outputs
mkdir -p outputs
your-app generate-screenshots --output outputs/

# 2. Commit changes including outputs
git add outputs/
git add src/  # your code changes
git commit -m "feat: update UI components"

# 3. Push to main or develop branch
git push origin main

# 4. The post-commit workflow will automatically:
#    - Detect the images in outputs/
#    - Run visual regression testing
#    - Log results to the workflow output
```

## Example 2: Manual Execution with Force Run

Test the visual regression system even without existing images:

```bash
# Go to GitHub Actions ‚Üí Post-Commit Visual Regression ‚Üí Run workflow
# Select options:
#   - Branch: main (or your target branch)
#   - Force run: true

# This will:
# 1. Generate sample test images automatically
# 2. Run the full visual regression testing pipeline
# 3. Validate that the system is working correctly
```

## Example 3: Integration with External CI

In your external repository's workflow:

```yaml
# .github/workflows/ci.yml
name: CI with Post-Commit Visual Monitoring

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Build application
        run: |
          npm install
          npm run build
      
      - name: Generate visual outputs
        run: |
          mkdir -p outputs
          npm run test:visual  # generates images to outputs/
      
      - name: Commit outputs (for push events only)
        if: github.event_name == 'push'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add outputs/
          git commit -m "Update visual outputs" --allow-empty

  # Visual regression testing for PRs
  visual-regression-pr:
    needs: build-and-test
    if: github.event_name == 'pull_request'
    uses: mpiispanen/image-comparison-and-update/.github/workflows/visual-diff.yml@main
    with:
      outputs_directory: outputs
      pr_number: ${{ github.event.pull_request.number }}
    permissions:
      contents: write
      issues: write
      pull-requests: write

  # Post-commit monitoring for main branch
  post-commit-monitoring:
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    uses: mpiispanen/image-comparison-and-update/.github/workflows/post_commit_visual_regression.yml@main
    permissions:
      contents: write
      issues: write
      pull-requests: write
```

## Expected Outcomes

### When Images Are Present
```
‚úÖ Found 3 test images in outputs/ directory
üìä Running visual regression testing...
‚úÖ VISUAL REGRESSION TEST PASSED
   All images match their golden masters
   No visual regressions detected in this commit
```

### When No Images Are Present
```
‚ÑπÔ∏è No test images found in outputs/ directory
Post-commit visual regression will be skipped

This is normal if:
- No visual changes were made in this commit  
- Test images are generated by a separate CI process
- This commit only contains code changes without visual outputs
```

### When Visual Differences Are Detected
```
‚ùå VISUAL REGRESSION TEST FAILED
   Visual changes detected that may need review
   Check the visual-diff workflow results for details

üì¶ Download Results: [Link to workflow artifacts]
```

## Best Practices

1. **Organize Visual Outputs**: Keep all visual test outputs in the `outputs/` directory
2. **Meaningful Commit Messages**: Use clear commit messages when adding visual changes
3. **Monitor Results**: Check workflow logs for post-commit visual regression results
4. **Handle Failures**: Investigate visual regression failures promptly on main branch
5. **Use Force Run**: Periodically test the system with force_run to ensure it's working

## Troubleshooting

### Workflow Doesn't Run
- Check that images are in the `outputs/` directory
- Verify push is to `main` or `develop` branch
- Check workflow file syntax with `yaml.safe_load()`

### Workflow Runs But Finds No Images
- Ensure images are committed to the repository
- Check file paths match the expected `outputs/*.png` pattern
- Verify images are not in `.gitignore`

### Visual Regression Failures
- Download workflow artifacts to see visual differences
- Compare current outputs with golden master images
- Use `/accept-image <filename>` to accept intentional changes

## Advanced Usage

### Custom Branch Triggers
Modify the workflow to run on additional branches:

```yaml
on:
  push:
    branches: [main, develop, staging]  # Add more branches
    paths:
      - 'outputs/**'
      - 'golden/**'
```

### Issue Creation for Failures
Uncomment the issue creation code in the workflow to automatically create GitHub issues when visual regressions are detected on the main branch.